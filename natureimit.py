# -*- coding: utf-8 -*-
"""NatureImit.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Zk6FPE3-CoalwBrxBvwoNX744B8nemaj
"""

!pip install sentinelsat

import requests
import json

# URL for India's GeoJSON boundary from OSM
url = "https://raw.githubusercontent.com/johan/world.geo.json/master/countries/IND.geo.json"

# Download and save the file
response = requests.get(url)
if response.status_code == 200:
    with open("india.geojson", "w") as f:
        json.dump(response.json(), f)
    print("India GeoJSON downloaded successfully!")
else:
    print("Failed to download India GeoJSON")

from sentinelsat import SentinelAPI, read_geojson, geojson_to_wkt
from datetime import date

# connect to the API
classsentinelsat.sentinel.SentinelAPI(EricSi, 1%ChangeGodsDestiny, api_url='https://scihub.copernicus.eu/apihub/')
#api = SentinelAPI('Eric Si', '1%ChangeGodsDestiny', 'https://apihub.copernicus.eu/apihub')

# download single scene by known product id
api.download(<product_id>)

# search by polygon, time, and Hub query keywords
footprint = geojson_to_wkt(read_geojson('map.geojson'))
products = api.query(footprint,
                     date = ('20151219', date(2015, 12, 29)),
                     platformname = 'Sentinel-2',
                     cloudcoverpercentage = (0, 30))

# download all results from the search
api.download_all(products)

# GeoJSON FeatureCollection containing footprints and metadata of the scenes
api.to_geojson(products)

# GeoPandas GeoDataFrame with the metadata of the scenes and the footprints as geometries
api.to_geodataframe(products)

from sentinelsat import geojson_to_wkt

india_bbox = {
    "type": "Polygon",
    "coordinates": [
        [
            [68.1767, 7.9655], [97.4026, 7.9655],
            [97.4026, 35.4940], [68.1767, 35.4940],
            [68.1767, 7.9655]
        ]
    ]
}

footprint = geojson_to_wkt(india_bbox)

from sentinelsat import SentinelAPI, read_geojson, geojson_to_wkt
from datetime import date

# Connect to the API (Replace with your actual credentials)
api = SentinelAPI('Eric Si', '1%ChangeGodsDestiny', 'https://scihub.copernicus.eu/apihub')

# Read the AOI (Area of Interest) from a GeoJSON file
footprint = geojson_to_wkt(read_geojson('footprint'))

# Search for Sentinel-2 images within the given time range and cloud coverage
products = api.query(footprint,
                     date=('2015-12-19', '2015-12-29'),  # Corrected date format
                     platformname='Sentinel-2',
                     cloudcoverpercentage=(0, 30))  # Filter images with cloud cover between 0-30%

# Download all results from the search
api.download_all(products)

# Convert results to GeoJSON format
geojson_data = api.to_geojson(products)

# Convert results to a GeoPandas DataFrame for spatial analysis
geodataframe = api.to_geodataframe(products)

# Print the number of products found
print(f"Found {len(products)} Sentinel-2 images.")

import math
import datetime

def calculate_solar_position(latitude, longitude, date):
  """Calculates the solar position (altitude and azimuth) for a given location and date.

  Args:
    latitude: Latitude in degrees.
    longitude: Longitude in degrees.
    date: Datetime object.

  Returns:
    A tuple containing the solar altitude and azimuth in degrees.
  """

  # Calculate day of the year
  day_of_year = date.timetuple().tm_yday

  # Calculate equation of time
  B = (360.0 / 365.0) * (day_of_year - 81)
  EoT = 9.87 * math.sin(2 * B) - 7.53 * math.cos(B) - 1.5 * math.sin(B)

  # Calculate solar time
  time_difference = longitude / 15.0
  solar_time = date.hour + time_difference + EoT / 60.0

  # Calculate hour angle
  hour_angle = 15 * (solar_time - 12)

  # Calculate solar declination
  declination = 23.45 * math.sin(360.0 / 365.0 * (284 + day_of_year))

  # Calculate solar altitude
  altitude = math.asin(math.sin(math.radians(latitude)) * math.sin(math.radians(declination)) +
                      math.cos(math.radians(latitude)) * math.cos(math.radians(declination)) *
                      math.cos(math.radians(hour_angle)))
  altitude = math.degrees(altitude)

  # Calculate solar azimuth
  azimuth = math.acos((math.sin(math.radians(altitude)) * math.sin(math.radians(latitude)) -
                       math.sin(math.radians(declination))) /
                      (math.cos(math.radians(altitude)) * math.cos(math.radians(latitude))))
  azimuth = math.degrees(azimuth)

  if math.sin(math.radians(hour_angle)) > 0:
    azimuth = 360 - azimuth

  return altitude, azimuth


if __name__ == "__main__":
  # Get user input for latitude, longitude, and date
  latitude = float(input("Enter latitude (degrees): "))
  longitude = float(input("Enter longitude (degrees): "))
  year = int(input("Enter year: "))
  month = int(input("Enter month (1-12): "))
  day = int(input("Enter day (1-31): "))
  hour = int(input("Enter hour (0-23): "))

  date = datetime.datetime(year, month, day, hour)

  # Calculate solar position
  altitude, azimuth = calculate_solar_position(latitude, longitude, date)

  print(f"Solar altitude: {altitude:.2f} degrees")
  print(f"Solar azimuth: {azimuth:.2f} degrees")

  # You can further develop this code to:
  # - Plot the sun's path across the sky for the entire day.
  # - Calculate sunrise and sunset times.
  # - Consider atmospheric refraction for more accurate calculations.

